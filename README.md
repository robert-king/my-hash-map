# my-hash-map

In march 2017, I made a hashmap, for golang. Without any fine tuning, I benchmarked it against the standard library hash map, and it performed only 20% slower (I believe with tuning it could become faster in some rare circumstances, particularly where the majority of the list of keys is known ahead of time).
It works on 64 bit numbers for now. It creates buckets for the 64 bit numbers using the first N bits of each number (N is chosen based on memory usage vs collisions compromise). If any bucket has collisions, it figures out, of this group of colliding numbers, what is the minimum number of bits we need to look at of each of these numbers to distinguish between them. It then learns for each bucket which bits are important, and when doing lookups, it quickly finds the right bucket, and automatically can use those bits to find the exact location within the bucket. To figure out which bits were important, I used a combination of brute force and Integer Programming, but there is also a greedy algorithm that could be used to improve write speed. I didnâ€™t investigate further but because it packs the data into an array not much bigger than the number of keys, iterating over the data should be faster than iterating over a traditional hash map where you have to iterate over the key space and lookup each item.

Note: runtime hashmap is here: https://golang.org/src/runtime/hashmap_fast.go?s=2939:3009#L100